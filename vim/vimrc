" .vimrc
" Author: Caneill Pierre-Yves <pyc@moeryn.com>

set nocompatible

filetype plugin on
filetype plugin indent on

" {{{ Plugins

call plug#begin('~/.vim/bundle')

Plug 'SirVer/ultisnips'
Plug 'vim-scripts/a.vim'
Plug 'scrooloose/nerdtree'
Plug 'scrooloose/nerdcommenter'
Plug 'tpope/vim-fugitive'
Plug 'kien/ctrlp.vim'
Plug 'vim-airline/vim-airline'
Plug 'junegunn/seoul256.vim'
Plug 'ervandew/supertab'
Plug 'airblade/vim-gitgutter'
Plug 'editorconfig/editorconfig-vim'
Plug 'benekastah/neomake'
Plug 'pangloss/vim-javascript'
Plug 'kshenoy/vim-signature'
Plug 'marijnh/tern_for_vim', { 'do': 'npm install'}
Plug 'othree/html5.vim'
Plug 'Slava/vim-spacebars'
Plug 'kassio/neoterm'
Plug 'bruno-/vim-man'
Plug 'jlanzarotta/bufexplorer'
Plug 'vim-scripts/gtags.vim'
Plug 'octol/vim-cpp-enhanced-highlight'
Plug 'Raimondi/delimitMate'
Plug 'vim-scripts/genutils'
Plug 'sjl/badwolf'
Plug 'lyuts/vim-rtags'
Plug 'equalsraf/neovim-gui-shim'
Plug 'Shougo/echodoc.vim'

if has("nvim")
   Plug 'critiqjo/lldb.nvim', { 'do': ':UpdateRemotePlugins' }
endif

Plug 'Shougo/context_filetype.vim'
Plug 'Valloric/YouCompleteMe',  { 'do': './install.py --clang-completer' }
" Plug 'scrooloose/syntastic'

if exists("g:moeryn_work") && g:moeryn_work == 1
    Plug 'Moeryn/vim-perforce'
endif

Plug 'mileszs/ack.vim'
Plug 'rhysd/vim-clang-format'

call plug#end()

" }}}
" {{{ Basic options
" {{{ cursor line

set cursorline
hi CursorLine term=bold cterm=bold ctermbg=black

augroup cline
    au!
    au WinLeave,InsertEnter * set nocursorline
    au WinEnter,InsertLeave * set cursorline
augroup END

" }}}
"  {{{ Wildmenu completion

set wildmenu
set wildmode=list:longest,full

set wildignore+=.hg,.git,.svn                    " Version control
set wildignore+=*.aux,*.out,*.toc                " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg   " binary images
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.sw?                            " Vim swap files
set wildignore+=*.luac                           " Lua byte code
set wildignore+=*.pyc                            " Python byte code
set wildignore+=*.orig                           " Merge resolution files

" }}}
" {{{ restore cursor position

au BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif

" }}}

"TODO fails when reloading
"set encoding=utf-8
set backspace=indent,eol,start

set ttimeout
set ttimeoutlen=0

set incsearch
set hlsearch

set autoindent
set noswapfile

set hidden
set noesckeys
set splitbelow
set splitright
set showbreak=

" list
set listchars=eol:¬,tab:➤\ ,trail:-,extends:>,precedes:<,nbsp:¤
set list
"hi SpecialKey ctermbg=red


" modeline
set modeline
set modelines=5

set lazyredraw
set undolevels=1000   " increase number of undos possible
set ttyfast           " fast terminal
set showmatch         " show matching bracket
set report=0          " report the number of lines changed
set laststatus=2      " always have a status line
set foldmethod=marker " folding => {{{ }}}
set wildmenu
set tags=tags;/,.tags;/,TAG;/

" Don't try to highlight lines longer than 800 characters.
set synmaxcol=800

set complete=.,w,b,u,i,t

"undo settings
set undodir=~/.vim/undofiles
set undofile
set colorcolumn=+1 "mark the ideal max text width

" Enable color in the terminal for the powerline in some terminal
set t_Co=256

" }}}
" {{{ Plugins
" {{{ Synastic

let g:syntastic_error_symbol = '✗'
let g:syntastic_warning_symbol = '⚠'

let g:syntastic_mode_map = { 'mode': 'active',
         \ 'passive_filetypes': [ ] }
let g:syntastic_ignore_files = ['^/usr/include/']
let g:syntastic_auto_loc_list=1
let g:syntastic_auto_jump=0
let g:syntastic_check_on_open=1
let g:syntastic_silent_make=0

let g:syntastic_c_compiler = 'clang'
let g:syntastic_c_compiler_options = ''
let g:syntastic_c_include_dirs = [ ]
let g:syntastic_c_no_include_search = 1
let g:syntastic_c_no_default_include_dirs = 1

let g:syntastic_cpp_compiler = 'clang++'
let g:syntastic_cpp_compiler_options = ''
let g:syntastic_cpp_include_dirs = [ ]
let g:syntastic_cpp_no_include_search = 1
let g:syntastic_cpp_no_default_include_dirs = 1

command! -nargs=* -bar -bang -count=0 -complete=dir E Explore <args>

" }}}
" {{{ signature

let g:SignatureMap = {
            \ 'Leader'             :  "m",
            \ 'PlaceNextMark'      :  "m,",
            \ 'ToggleMarkAtLine'   :  "m.",
            \ 'PurgeMarksAtLine'   :  "m-",
            \ 'DeleteMark'         :  "dm",
            \ 'PurgeMarks'         :  "m<Space>",
            \ 'PurgeMarkers'       :  "m<BS>",
            \ 'GotoNextLineAlpha'  :  "'n",
            \ 'GotoPrevLineAlpha'  :  "'p",
            \ 'GotoNextSpotAlpha'  :  "`]",
            \ 'GotoPrevSpotAlpha'  :  "`[",
            \ 'GotoNextLineByPos'  :  "]'",
            \ 'GotoPrevLineByPos'  :  "['",
            \ 'GotoNextSpotByPos'  :  "]`",
            \ 'GotoPrevSpotByPos'  :  "[`",
            \ 'GotoNextMarker'     :  "[+",
            \ 'GotoPrevMarker'     :  "[-",
            \ 'GotoNextMarkerAny'  :  "]=",
            \ 'GotoPrevMarkerAny'  :  "[=",
            \ 'ListLocalMarks'     :  "m/",
            \ 'ListLocalMarkers'   :  "m?"
            \ }

" }}}
" {{{ UltiSnips

let g:UltiSnipsExpandTrigger       = "<tab>"
let g:UltiSnipsListSnippets        = "<c-l>"
let g:UltiSnipsJumpForwardTrigger  = "<c-tab>"
let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"
let g:SuperTabDefaultCompletionType = '<C-tab>'

let g:UltiSnipsEditSplit = 'vertical'

" }}}
" {{{ ctrlp

let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files && git submodule -q foreach ''for file in $(git ls-files); do echo $name/$file; done''']

" }}}
" {{{ Neomake

if has("nvim")
    let g:syntastic_python_checkers = ['']

    let g:neomake_cpp_enabled_makers = ['clangcheck', 'clangtidy']
    let g:neomake_cpp_clangcheck_args=['-p', '/home/pcaneill/dev/murex/.build/normal', '-extra-arg=-fno-color-diagnostics', '-extra-arg=-fdiagnostics-format=clang', '-extra-arg=-fno-caret-diagnostics',  '-extra-arg=-fshow-source-location', '-extra-arg=-fshow-column"']
    let g:neomake_cpp_clangtidy_args=['-p', '/home/pcaneill/dev/murex/.build/normal', '-extra-arg=-fno-color-diagnostics', '-extra-arg=-fdiagnostics-format=clang', '-extra-arg=-fno-caret-diagnostics',  '-extra-arg=-fshow-source-location', '-extra-arg=-fshow-column"']
    "autocmd BufWritePost *.cpp :Neomake clangcheck
    "autocmd BufWritePost *.c :Neomake clangcheck
    "autocmd BufWritePost *.hpp :Neomake clangcheck
    "autocmd BufWritePost *.h :Neomake clangcheck

    let g:neomake_python_enable_makers = ['pylint']
    let g:neomake_javascript_enable_makers = ['jshint']
    let g:neomake_open_list=1
    let g:neomake_serialize_abort_on_error=1
    let g:neomake_serialize=1
    autocmd BufWritePost *.py :Neomake pylint
    autocmd BufWritePost *.js :Neomake jshint
endif

" }}}
" {{{ Completion

let g:ycm_key_list_select_completion = ['<C-TAB>', '<Down>']
let g:ycm_key_list_previous_completion = ['<C-S-TAB>', '<Up>']

"set completeopt+=preview

let g:ycm_seed_identifiers_with_syntax = 1
let g:ycm_autoclose_preview_window_after_insertion = 1
let g:ycm_open_loclist_on_ycm_diags = 1
let g:ycm_always_populate_location_list = 1
let g:ycm_confirm_extra_conf = 0
let g:ycm_collect_identifiers_from_tags_files = 0
let g:ycm_add_preview_to_completeopt = 0
let g:ycm_complete_in_comments = 1
let g:ycm_complete_in_strings = 1

" }}}
" {{{ echodoc


set noshowmode " I use airline anyway + it tampers with echodoc.
let g:echodoc_enable_at_startup = 1
set completeopt+=menuone
set completeopt-=preview
set shortmess+=c

" }}}
" {{{ Terminal & Neoterm

if has("nvim")
    " escape
    tnoremap <esc> <C-\><C-n>

    " move from terminal to other pane
    tnoremap <C-h> <C-\><C-n><C-w>h
    tnoremap <C-j> <C-\><C-n><C-w>j
    tnoremap <C-k> <C-\><C-n><C-w>k
    tnoremap <C-l> <C-\><C-n><C-w>l

    " always be in insert mode when entering terminal
    autocmd BufWinEnter,WinEnter term://* startinsert

    " always leave insert mode when leaving terminal
    autocmd BufLeave term://* stopinsert

    " Neoterm

    let g:neoterm_position = 'vertical'
    let g:neoterm_automap_keys = ',tt'

    " Useful maps
    " hide/close all terminals
    nnoremap <silent> ,th :call neoterm#close_all()<cr>
    " clear terminal
    nnoremap <silent> ,tl :call neoterm#clear()<cr>
    " kills the current job (send a <c-c>)
    nnoremap <silent> ,tc :call neoterm#kill()<cr>

    " Git commands
    command! -nargs=+ Tg :T git <args>
endif

" }}}
" {{{ tern

if exists("g:moeryn_tern") && g:moeryn_tern != 0
    call tern#Enable()
    autocmd FileType javascript setlocal omnifunc=tern#Complete
endif

" }}}
" {{{ gitgutter

let g:gitgutter_realtime = 1

" }}}
" {{{ code syntax

let g:cpp_class_scope_highlight=0
let g:cpp_experimental_template_highlight=1

" }}}
" {{{ Ag

let g:ackprg = 'ag --vimgrep'

" }}}
" {{{ delimitMate

let delimitMate_expand_cr=1

" }}}
" {{{ ClangFormat

let g:clang_format#detect_style_file = 1
autocmd FileType c,cpp,objc nnoremap <buffer><Leader>cf :<C-u>ClangFormat<cr>zo
autocmd FileType c,cpp,objc vnoremap <buffer><Leader>cf :ClangFormat<cr>zo

" }}}
" }}}
" {{{ Functions

let g:current_theme = "seoul256"
function! SwitchTheme()
    if g:current_theme ==? "seoul256"
        colo seoul256-light
        let g:current_theme = "seoul256-light"
        return
    endif
    if g:current_theme ==? "seoul256-light"
        colo badwolf
        let g:current_theme = "badwolf"
        return
    endif
    if g:current_theme ==? "badwolf"
        colo seoul256
        let g:current_theme = "seoul256"
        return
    endif
endfunction

" }}}
" {{{ Mapping

let mapleader = ","

" {{{ Fn

" follow tag
noremap <F2> :YcmCompleter GoToDefinition<cr>
"noremap <F2> :exec("tag ".expand("<cword>"))<cr>
noremap <C-F2> :GtagsCursor<cr>

" bufExplorer
map <F3> <leader>be

" grep on the current word
noremap <F4> :Ack <cword><cr>

set pastetoggle=<F5>

nnoremap <F6> :exec("call SwitchTheme()")<cr>

" spell check
noremap <F8> :setlocal spell! spelllang=en_us<cr>

" horizontal split + next buffer
noremap <F9> :split<cr>:bn<cr>
" vertical split + next buffer
noremap <F10> :vsplit<cr>:bn<cr>

" make
noremap  <F11> :make!<cr><cr>
inoremap <F11> <esc>:make!<cr><cr>

" remove trailing spaces
noremap <F12> mcHmh:%s/ \+$//ge<cr>'hzt`c

" }}}
" {{{ Normal

" next quickfix
noremap +        :cnext<cr>
noremap <kPlus>  :cnext<cr>

" previous quickfix
noremap -        :cprev<cr>
noremap <kMinus> :cprev<cr>

" next loclist (YcmDiags, neomake)
noremap <leader>n :lnext<cr>
" previous loclist (YcmDiags, neomake)
noremap <leader>b :lprev<cr>

" change directory to the file being edited
nnoremap ,cd :cd %:p:h<cr>

" Move begining of line and end of line
noremap H ^
noremap L $

" move to left buffer
noremap  <C-Left>   <C-w><Left>
noremap! <C-Left>   <Esc> <C-w><Left>
noremap  <C-h>      <C-w><Left>
noremap! <C-h>      <Esc> <C-w><Left>
" move to right buffer
noremap  <C-Right>  <C-w><Right>
noremap! <C-Right>  <Esc> <C-w><Right>
noremap  <C-l>      <C-w><Right>
noremap! <C-l>      <Esc> <C-w><Right>
" move to buffer above
noremap  <C-Up>     <C-w><Up>
noremap! <C-Up>     <Esc> <C-w><Up>
noremap  <C-k>      <C-w><Up>
noremap! <C-k>      <Esc> <C-w><Up>
" move to buffer below
noremap  <C-Down>   <C-w><Down>
noremap! <C-Down>   <Esc> <C-w><Down>
noremap  <C-j>      <C-w><Down>
noremap! <C-j>      <Esc> <C-w><Down>

" scroll up
noremap <S-Up> <C-Y>
" scroll down
noremap <S-Down> <C-E>

" resize windows
noremap <A-l> :exec("5winc >")<cr>
noremap <A-h> :exec("5winc <")<cr>
noremap <A-k> :exec("5winc -")<cr>
noremap <A-j> :exec("5winc +")<cr>

" Move current line up and down
noremap <leader>- ddp
noremap <leader>_ ddkP

" Open vimrc / nvimrc and source it
nnoremap <leader>ev :vsplit $HOME/CONFIG/vim/vimrc<cr>
nnoremap <leader>env :vsplit $HOME/CONFIG/vim/nvimrc<cr>
nnoremap <leader>sv :source $MYVIMRC<cr>

" Add semicolumn at the end of the line
nnoremap <leader>; :exec("normal! mqA;\<lt>esc>`q")<cr>

nnoremap K :q<cr>
nnoremap :q<cr> :call input("use `K` instead")<cr>

nnoremap s :w<cr>
nnoremap :w<cr> :call input("use `s` instead")<cr>

" Toggle line numbers
nnoremap <leader>l :setlocal number!<cr>

" Select a block and sort it
nnoremap <leader>s vip:!sort<cr>

" Reselect last-pasted text
nnoremap gp `[v`]

nnoremap <c-s> mzzMzvzz15<c-e>`z:Pulse<cr>

nnoremap <leader>i :YcmCompleter GoToInclude<cr>
nnoremap <leader>d :YcmCompleter GoToDeclaration<cr>
nnoremap <leader>t :YcmCompleter GoTo<cr>
nnoremap <leader>gt :YcmCompleter GetType<cr>
nnoremap <leader>gp :YcmCompleter GetParent<cr>
nnoremap <leader>f :YcmCompleter FixIt<cr>:ll<cr>
"nnoremap <leader>c :YcmDiags<cr>
nnoremap <leader>ct :Neomake clangtidy<cr>
nnoremap <leader>cn :Neomake clangcheck<cr>

" }}}
" {{{ Interactive

" forbid non-breakable spaces
inoremap   <Space>

" Uppercase last word
inoremap <C-u> <esc>vbU<esc>ea

" Surround last word with quotes
inoremap <leader>" <esc>viw<esc>a"<esc>hbi"<esc>lela

inoremap jk <esc>

inoremap <C-l> <esc>la
inoremap <C-h> <esc>ha
inoremap <C-e> <esc>ea

" }}}
" {{{ Visual

" Surround selected text with quotes
vnoremap <leader>" <esc>`<i"<esc>`>a"<esc>l

" Search the references of the copied text
vnoremap <C-F2> y<esc>:exec("Gtags -g ^[sg]et_ ".expand("<c-r>0"))<cr>

" }}}
" {{{ Operator-Pendig Mapping

" inside parens
onoremap p i(
onoremap np :<c-u>normal! f(vi(<cr>i
onoremap pp :<c-u>normal! F)vi(<cr>i
onoremap n" :<c-u>normal! f"vi"<cr>i

" }}}
" }}}
" {{{ Code formatting

set tabstop=2
set softtabstop=2
set expandtab
set textwidth=0
set shiftwidth=2

set cinoptions=
set cinoptions+=N-s         " No namespace indentation
set cinoptions+=L0.5s       " align labels at 0.5 shiftwidth
set cinoptions+=:0.5s,=0.5s " same for case labels and code following labels
set cinoptions+=g0.5s,h0.5s " same for C++ stuff
set cinoptions+=t0          " type on the line before the function is not indented
set cinoptions+=(0,Ws       " indent in functions ( ... ) when it breaks
set cinoptions+=m1          " align the closing ) properly
set cinoptions+=j1,J1       " java/javascript -> fixes blocks

" Doxygen
au! Syntax {cpp,c,d,javascript}
au Syntax {cpp,c,d,javascript} runtime syntax/doxygen.vim

" }}}
" {{{ Next and Last
"
" Author: Steve Losh <steve@stevelosh.com>
" Source: http://bitbucket.org/sjl/dotfiles/src/tip/vim/
"
" Motion for "next/last object".  "Last" here means "previous", not "final".
" Unfortunately the "p" motion was already taken for paragraphs.
"
" Next acts on the next object of the given type, last acts on the previous
" object of the given type.  These don't necessarily have to be in the current
" line.
"
" Currently works for (, [, {, and their shortcuts b, r, B.
"
" Next kind of works for ' and " as long as there are no escaped versions of
" them in the string (TODO: fix that).  Last is currently broken for quotes
" (TODO: fix that).
"
" Some examples (C marks cursor positions, V means visually selected):
"
" din'  -> delete in next single quotes                foo = bar('spam')
"                                                      C
"                                                      foo = bar('')
"                                                                C
"
" canb  -> change around next parens                   foo = bar('spam')
"                                                      C
"                                                      foo = bar
"                                                               C
"
" vin"  -> select inside next double quotes            print "hello ", name
"                                                       C
"                                                      print "hello ", name
"                                                             VVVVVV

onoremap an :<c-u>call <SID>NextTextObject('a', '/')<cr>
xnoremap an :<c-u>call <SID>NextTextObject('a', '/')<cr>
onoremap in :<c-u>call <SID>NextTextObject('i', '/')<cr>
xnoremap in :<c-u>call <SID>NextTextObject('i', '/')<cr>

onoremap al :<c-u>call <SID>NextTextObject('a', '?')<cr>
xnoremap al :<c-u>call <SID>NextTextObject('a', '?')<cr>
onoremap il :<c-u>call <SID>NextTextObject('i', '?')<cr>
xnoremap il :<c-u>call <SID>NextTextObject('i', '?')<cr>


function! s:NextTextObject(motion, dir)
    let c = nr2char(getchar())
    let d = ''

    if c ==# "b" || c ==# "(" || c ==# ")"
        let c = "("
    elseif c ==# "B" || c ==# "{" || c ==# "}"
        let c = "{"
    elseif c ==# "r" || c ==# "[" || c ==# "]"
        let c = "["
    elseif c ==# "'"
        let c = "'"
    elseif c ==# '"'
        let c = '"'
    else
        return
    endif

    " Find the next opening-whatever.
    execute "normal! " . a:dir . c . "\<cr>"

    if a:motion ==# 'a'
        " If we're doing an 'around' method, we just need to select around it
        " and we can bail out to Vim.
        execute "normal! va" . c
    else
        " Otherwise we're looking at an 'inside' motion.  Unfortunately these
        " get tricky when you're dealing with an empty set of delimiters because
        " Vim does the wrong thing when you say vi(.

        let open = ''
        let close = ''

        if c ==# "("
            let open = "("
            let close = ")"
        elseif c ==# "{"
            let open = "{"
            let close = "}"
        elseif c ==# "["
            let open = "\\["
            let close = "\\]"
        elseif c ==# "'"
            let open = "'"
            let close = "'"
        elseif c ==# '"'
            let open = '"'
            let close = '"'
        endif

        " We'll start at the current delimiter.
        let start_pos = getpos('.')
        let start_l = start_pos[1]
        let start_c = start_pos[2]

        " Then we'll find it's matching end delimiter.
        if c ==# "'" || c ==# '"'
            " searchpairpos() doesn't work for quotes, because fuck me.
            let end_pos = searchpos(open)
        else
            let end_pos = searchpairpos(open, '', close)
        endif

        let end_l = end_pos[0]
        let end_c = end_pos[1]

        call setpos('.', start_pos)

        if start_l == end_l && start_c == (end_c - 1)
            " We're in an empty set of delimiters.  We'll append an "x"
            " character and select that so most Vim commands will do something
            " sane.  v is gonna be weird, and so is y.  Oh well.
            execute "normal! ax\<esc>\<left>"
            execute "normal! vi" . c
        elseif start_l == end_l && start_c == (end_c - 2)
            " We're on a set of delimiters that contain a single, non-newline
            " character.  We can just select that and we're done.
            execute "normal! vi" . c
        else
            " Otherwise these delimiters contain something.  But we're still not
            " sure Vim's gonna work, because if they contain nothing but
            " newlines Vim still does the wrong thing.  So we'll manually select
            " the guts ourselves.
            let whichwrap = &whichwrap
            set whichwrap+=h,l

            execute "normal! va" . c . "hol"

            let &whichwrap = whichwrap
        endif
    endif
endfunction

" }}}
" {{{ Color scheme

syntax on
set background=dark

hi Comment      cterm=none       ctermfg=blue       ctermbg=none
hi doxygenBrief cterm=none       ctermfg=cyan       ctermbg=none
hi Folded       cterm=none       ctermfg=brown      ctermbg=none

hi Visual       cterm=reverse    ctermfg=none       ctermbg=none
hi IncSearch    cterm=none       ctermfg=red        ctermbg=none
hi Search       cterm=underline  ctermfg=red        ctermbg=none

hi StatusLine   cterm=none       ctermfg=white      ctermbg=blue
hi StatusLineNc cterm=none       ctermfg=black      ctermbg=white
hi WildMenu     cterm=none       ctermfg=white      ctermbg=none
hi VertSplit    cterm=none       ctermfg=darkgray   ctermbg=none
hi NonText      cterm=none       ctermfg=darkgray   ctermbg=none

hi MatchParen   cterm=underline  ctermfg=white      ctermbg=red
hi Pmenu        cterm=none       ctermfg=gray       ctermbg=black
hi PmenuSel     cterm=none       ctermfg=black      ctermbg=gray
hi PmenuSbar    cterm=none       ctermfg=blue       ctermbg=blue
hi PmenuThumb   cterm=none       ctermfg=gray       ctermbg=gray

hi SpellBad     cterm=underline  ctermfg=lightred   ctermbg=none
hi SpellCap     cterm=none       ctermfg=lightred   ctermbg=none
hi SpellLocal   cterm=underline  ctermfg=darkgreen  ctermbg=none
hi SpellRare    cterm=none       ctermfg=none       ctermbg=none

hi javaScriptTpl       cterm=none ctermfg=darkgreen ctermbg=none
hi javaScriptTplMark   cterm=none ctermfg=magenta ctermbg=none

" Reload the colorscheme whenever we write the file.
augroup color_badwolf_dev
    au!
    au BufWritePost badwolf.vim color badwolf
augroup END

" Highlight VCS conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

colo badwolf

" }}}
