" .vimrc
" Author: Caneill Pierre-Yves <pyc@moeryn.com>

set nocompatible

" {{{ Pathogen

call pathogen#infect()
call pathogen#helptags()

filetype plugin on
filetype plugin indent on

" }}}
" {{{ Basic options
" {{{ cursor line

set cursorline
hi CursorLine term=bold cterm=bold ctermbg=black

augroup cline
    au!
    au WinLeave,InsertEnter * set nocursorline
    au WinEnter,InsertLeave * set cursorline
augroup END

"* }}}
"  {{{ Wildmenu completion

set wildmenu
set wildmode=list:longest,full

set wildignore+=.hg,.git,.svn                    " Version control
set wildignore+=*.aux,*.out,*.toc                " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg   " binary images
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.sw?                            " Vim swap files
set wildignore+=*.luac                           " Lua byte code
set wildignore+=*.pyc                            " Python byte code
set wildignore+=*.orig                           " Merge resolution files

" }}}
" {{{ restore cursor position

au BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal g`\"" |
    \ endif

" }}}
" {{{ color scheme

syntax on
set background=dark
colo badwolf

" Reload the colorscheme whenever we write the file.
augroup color_badwolf_dev
    au!
    au BufWritePost badwolf.vim color badwolf
augroup END

" Highlight VCS conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" }}}

"TODO set encoding=utf-8
set backspace=indent,eol,start

set incsearch
set hlsearch

set autoindent
set noswapfile

set hidden
set noesckeys
set splitbelow
set splitright
set showbreak=↪

" list
set listchars=eol:¬,tab:▸\ ,trail:-,extends:>,precedes:<,nbsp:¤
set list
"hi SpecialKey ctermbg=red


" modeline
set modeline
set modelines=5

set lazyredraw
set undolevels=1000   " increase number of undos possible
set ttyfast           " fast terminal
set showmatch         " show matching bracket
set report=0          " report the number of lines changed
set laststatus=2      " always have a status line
set foldmethod=marker " folding => {{{ }}}
set wildmenu
set tags=tags;/,.tags;/,TAG;/

" Don't try to highlight lines longer than 800 characters.
set synmaxcol=800

set complete=.,w,b,u,i,t

"undo settings
set undodir=~/.vim/undofiles
set undofile
set colorcolumn=+1 "mark the ideal max text width

" Enable color in the terminal for the powerline in some terminal
set t_Co=256

" }}}
" {{{ Plugins
" {{{ Synastic

if g:moeryn_syntastic == 1
    let g:syntastic_error_symbol = '✗'
    let g:syntastic_warning_symbol = '⚠'

    let g:syntastic_mode_map = { 'mode': 'active',
                               \ 'passive_filetypes': [ ] }
    let g:syntastic_ignore_files = ['^/usr/include/']
    let g:syntastic_auto_loc_list=1
    let g:syntastic_auto_jump=0
    let g:syntastic_check_on_open=1
    let g:syntastic_silent_make=0

    let g:syntastic_c_compiler = 'clang'
    let g:syntastic_c_compiler_options = ''
    let g:syntastic_c_include_dirs = [ ]
    let g:syntastic_c_no_include_search = 1
    let g:syntastic_c_no_default_include_dirs = 1

    let g:syntastic_cpp_compiler = 'clang++'
    let g:syntastic_cpp_compiler_options = ''
    let g:syntastic_cpp_include_dirs = [ ]
    let g:syntastic_cpp_no_include_search = 1
    let g:syntastic_cpp_no_default_include_dirs = 1
endif

command! -nargs=* -bar -bang -count=0 -complete=dir E Explore <args>

" }}}
" {{{ signature

let g:SignatureMap = {
            \ 'Leader'             :  "m",
            \ 'PlaceNextMark'      :  "m,",
            \ 'ToggleMarkAtLine'   :  "m.",
            \ 'PurgeMarksAtLine'   :  "m-",
            \ 'DeleteMark'         :  "dm",
            \ 'PurgeMarks'         :  "m<Space>",
            \ 'PurgeMarkers'       :  "m<BS>",
            \ 'GotoNextLineAlpha'  :  "'n",
            \ 'GotoPrevLineAlpha'  :  "'p",
            \ 'GotoNextSpotAlpha'  :  "`]",
            \ 'GotoPrevSpotAlpha'  :  "`[",
            \ 'GotoNextLineByPos'  :  "]'",
            \ 'GotoPrevLineByPos'  :  "['",
            \ 'GotoNextSpotByPos'  :  "]`",
            \ 'GotoPrevSpotByPos'  :  "[`",
            \ 'GotoNextMarker'     :  "[+",
            \ 'GotoPrevMarker'     :  "[-",
            \ 'GotoNextMarkerAny'  :  "]=",
            \ 'GotoPrevMarkerAny'  :  "[=",
            \ 'ListLocalMarks'     :  "m/",
            \ 'ListLocalMarkers'   :  "m?"
            \ }

" }}}
" {{{ UltiSnips

if g:moeryn_ultisnips == 1
    let g:UltiSnipsExpandTrigger       = "<tab>"
    let g:UltiSnipsListSnippets        = "<c-l>"
    let g:UltiSnipsJumpForwardTrigger  = "<tab>"
    let g:UltiSnipsJumpBackwardTrigger = "<c-k>"

    let g:UltiSnipsEditSplit = 'vertical'
endif

" }}}
" {{{ ctrlp

let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files && git submodule -q foreach ''for file in $(git ls-files); do echo $name/$file; done''']

" }}}
" {{{ colors

hi Comment      cterm=none       ctermfg=blue       ctermbg=none
hi doxygenBrief cterm=none       ctermfg=cyan       ctermbg=none
hi Folded       cterm=none       ctermfg=brown      ctermbg=none

hi Visual       cterm=reverse    ctermfg=none       ctermbg=none
hi IncSearch    cterm=none       ctermfg=red        ctermbg=none
hi Search       cterm=underline  ctermfg=red        ctermbg=none

hi StatusLine   cterm=none       ctermfg=white      ctermbg=blue
hi StatusLineNc cterm=none       ctermfg=black      ctermbg=white
hi WildMenu     cterm=none       ctermfg=white      ctermbg=none
hi VertSplit    cterm=none       ctermfg=darkgray   ctermbg=none
hi NonText      cterm=none       ctermfg=darkgray   ctermbg=none

hi MatchParen   cterm=underline  ctermfg=white      ctermbg=red
hi Pmenu        cterm=none       ctermfg=gray       ctermbg=black
hi PmenuSel     cterm=none       ctermfg=black      ctermbg=gray
hi PmenuSbar    cterm=none       ctermfg=blue       ctermbg=blue
hi PmenuThumb   cterm=none       ctermfg=gray       ctermbg=gray

hi SpellBad     cterm=underline  ctermfg=lightred   ctermbg=none
hi SpellCap     cterm=none       ctermfg=lightred   ctermbg=none
hi SpellLocal   cterm=underline  ctermfg=darkgreen  ctermbg=none
hi SpellRare    cterm=none       ctermfg=none       ctermbg=none

hi javaScriptTpl       cterm=none ctermfg=darkgreen ctermbg=none
hi javaScriptTplMark   cterm=none ctermfg=magenta ctermbg=none

" }}}
" {{{ youcompleteme

if g:moeryn_ycm == 1
    let g:ycm_key_list_select_completion = ['<C-TAB>', '<Down>']
    let g:ycm_key_list_previous_completion = ['<C-S-TAB>', '<Up>']
    let g:SuperTabDefaultCompletionType = '<C-Tab>'

    set completeopt+=preview

    let g:ycm_seed_identifiers_with_syntax = 1
    let g:ycm_autoclose_preview_window_after_insertion = 1
    let g:ycm_open_loclist_on_ycm_diags = 1
    let g:ycm_always_populate_location_list = 1
    let g:ycm_confirm_extra_conf = 0
    let g:ycm_collect_identifiers_from_tags_files = 0
    let g:ycm_add_preview_to_completeopt = 1
    let g:ycm_complete_in_comments = 1
    let g:ycm_complete_in_strings = 1
endif

" }}}
" {{{ tern

if g:moeryn_tern == 1
    call tern#Enable()
    autocmd FileType javascript setlocal omnifunc=tern#Complete
endif

" }}}
" {{{ gitgutter

let g:gitgutter_realtime = 1

" }}}
" {{{ code syntax

let g:cpp_class_scope_highlight=1

" }}}
" }}}
" {{{ Functions

let g:current_theme = "seoul256"
function! SwitchTheme()
    if g:current_theme ==? "seoul256"
        colo seoul256-light
        let g:current_theme = "seoul256-light"
        return
    endif
    if g:current_theme ==? "seoul256-light"
        colo badwolf
        let g:current_theme = "badwolf"
        return
    endif
    if g:current_theme ==? "badwolf"
        colo seoul256
        let g:current_theme = "seoul256"
        return
    endif
endfunction

" }}}
" {{{ Mapping

let mapleader = ","

" {{{ Fn

" follow man
noremap <F1> :exec("Vman ".expand("<cword>"))<cr>

" follow tag
noremap <F2> :exec("tag ".expand("<cword>"))<cr>
noremap <C-F2> :GtagsCursor<cr>

" bufExplorer
map <F3> <leader>be

" grep on the current word
noremap <F4> :gr! -w <cword><cr>

set pastetoggle=<F5>

nnoremap <F6> :exec("call SwitchTheme()")<cr>

" spell check
noremap <F8> :setlocal spell! spelllang=en_us<cr>

" horizontal split + next buffer
noremap <F9> :split<cr>:bn<cr>
" vertical split + next buffer
noremap <F10> :vsplit<cr>:bn<cr>

" make
noremap  <F11> :make!<cr><cr>
inoremap <F11> <esc>:make!<cr><cr>

" remove trailing spaces
noremap <F12> mcHmh:%s/ \+$//ge<cr>'hzt`c

" }}}
" {{{ Normal

" next compilation error
noremap +        :cnext<cr>
noremap <kPlus>  :cnext<cr>
" previous compilation error
noremap -        :cprev<cr>
noremap <kMinus> :cprev<cr>
" next syntastic error
noremap <S-Right> :lnext<cr>
" previous syntastic error
noremap <S-Left> :lprev<cr>

" change directory to the file being edited
nnoremap ,cd :cd %:p:h<cr>

" Move begining of line and end of line
noremap H ^
noremap L $

" move to left buffer
noremap  <C-Left>   <C-w><Left>
noremap! <C-Left>   <Esc> <C-w><Left>
noremap  <C-h>      <C-w><Left>
noremap! <C-h>      <Esc> <C-w><Left>
" move to right buffer
noremap  <C-Right>  <C-w><Right>
noremap! <C-Right>  <Esc> <C-w><Right>
noremap  <C-l>      <C-w><Right>
noremap! <C-l>      <Esc> <C-w><Right>
" move to buffer above
noremap  <C-Up>     <C-w><Up>
noremap! <C-Up>     <Esc> <C-w><Up>
noremap  <C-k>      <C-w><Up>
noremap! <C-k>      <Esc> <C-w><Up>
" move to buffer below
noremap  <C-Down>   <C-w><Down>
noremap! <C-Down>   <Esc> <C-w><Down>
noremap  <C-j>      <C-w><Down>
noremap! <C-j>      <Esc> <C-w><Down>

" scroll up
noremap <S-Up> <C-Y>
" scroll down
noremap <S-Down> <C-E>

" resize windows
noremap <A-l> :exec("5winc >")<cr>
noremap <A-h> :exec("5winc <")<cr>
noremap <A-k> :exec("5winc -")<cr>
noremap <A-j> :exec("5winc +")<cr>

" Move current line up and down
noremap <leader>- ddp
noremap <leader>_ ddkP

" Open vimrc / nvimrc and source it
nnoremap <leader>ev :vsplit $HOME/CONFIG/vim/vimrc<cr>
nnoremap <leader>env :vsplit $HOME/CONFIG/vim/nvimrc<cr>
nnoremap <leader>sv :source $MYVIMRC<cr>

" Add semicolumn at the end of the line
nnoremap <leader>; :exec("normal! mqA;\<lt>esc>`q")<cr>

nnoremap K :q<cr>
nnoremap :q<cr> :call input("use `K` instead")<cr>

nnoremap s :w<cr>
nnoremap :w<cr> :call input("use `s` instead")<cr>

" Toggle line numbers
nnoremap <leader>n :setlocal number!<cr>

nnoremap <leader>s vip:!sort<cr>

" Reselect last-pasted text
nnoremap gp `[v`]

nnoremap <c-z> mzzMzvzz15<c-e>`z:Pulse<cr>

" }}}
" {{{ Interactive

" forbid non-breakable spaces
inoremap   <Space>

" Uppercase last word
inoremap <C-u> <esc>vbU<esc>ea

" Surround last word with quotes
inoremap <leader>" <esc>viw<esc>a"<esc>hbi"<esc>lela

inoremap jk <esc>
inoremap <esc> :call input("use `jk` instead")<cr>

" }}}
" {{{ Visual

" Surround selected text with quotes
vnoremap <leader>" <esc>`<i"<esc>`>a"<esc>l

" Search the references of the copied text
vnoremap <C-F2> y<esc>:exec("Gtags -g ^[sg]et_ ".expand("<c-r>0"))<cr>

" }}}
" {{{ Operator-Pendig Mapping

" inside parens
onoremap p i(
onoremap np :<c-u>normal! f(vi(<cr>i
onoremap pp :<c-u>normal! F)vi(<cr>i
onoremap n" :<c-u>normal! f"vi"<cr>i

" }}}
" }}}
" {{{ Code formatting

set tabstop=2
set softtabstop=2
set expandtab
set textwidth=0
set shiftwidth=2

set cinoptions=
set cinoptions+=N-s         " No namespace indentation
set cinoptions+=L0.5s       " align labels at 0.5 shiftwidth
set cinoptions+=:0.5s,=0.5s " same for case labels and code following labels
set cinoptions+=g0.5s,h0.5s " same for C++ stuff
set cinoptions+=t0          " type on the line before the function is not indented
set cinoptions+=(0,Ws       " indent in functions ( ... ) when it breaks
set cinoptions+=m1          " align the closing ) properly
set cinoptions+=j1,J1       " java/javascript -> fixes blocks

" Doxygen
au! Syntax {cpp,c,d,javascript}
au Syntax {cpp,c,d,javascript} runtime syntax/doxygen.vim

" }}}
" {{{ Next and Last
"
" Author: Steve Losh <steve@stevelosh.com>
" Source: http://bitbucket.org/sjl/dotfiles/src/tip/vim/
"
" Motion for "next/last object".  "Last" here means "previous", not "final".
" Unfortunately the "p" motion was already taken for paragraphs.
"
" Next acts on the next object of the given type, last acts on the previous
" object of the given type.  These don't necessarily have to be in the current
" line.
"
" Currently works for (, [, {, and their shortcuts b, r, B.
"
" Next kind of works for ' and " as long as there are no escaped versions of
" them in the string (TODO: fix that).  Last is currently broken for quotes
" (TODO: fix that).
"
" Some examples (C marks cursor positions, V means visually selected):
"
" din'  -> delete in next single quotes                foo = bar('spam')
"                                                      C
"                                                      foo = bar('')
"                                                                C
"
" canb  -> change around next parens                   foo = bar('spam')
"                                                      C
"                                                      foo = bar
"                                                               C
"
" vin"  -> select inside next double quotes            print "hello ", name
"                                                       C
"                                                      print "hello ", name
"                                                             VVVVVV

onoremap an :<c-u>call <SID>NextTextObject('a', '/')<cr>
xnoremap an :<c-u>call <SID>NextTextObject('a', '/')<cr>
onoremap in :<c-u>call <SID>NextTextObject('i', '/')<cr>
xnoremap in :<c-u>call <SID>NextTextObject('i', '/')<cr>

onoremap al :<c-u>call <SID>NextTextObject('a', '?')<cr>
xnoremap al :<c-u>call <SID>NextTextObject('a', '?')<cr>
onoremap il :<c-u>call <SID>NextTextObject('i', '?')<cr>
xnoremap il :<c-u>call <SID>NextTextObject('i', '?')<cr>


function! s:NextTextObject(motion, dir)
    let c = nr2char(getchar())
    let d = ''

    if c ==# "b" || c ==# "(" || c ==# ")"
        let c = "("
    elseif c ==# "B" || c ==# "{" || c ==# "}"
        let c = "{"
    elseif c ==# "r" || c ==# "[" || c ==# "]"
        let c = "["
    elseif c ==# "'"
        let c = "'"
    elseif c ==# '"'
        let c = '"'
    else
        return
    endif

    " Find the next opening-whatever.
    execute "normal! " . a:dir . c . "\<cr>"

    if a:motion ==# 'a'
        " If we're doing an 'around' method, we just need to select around it
        " and we can bail out to Vim.
        execute "normal! va" . c
    else
        " Otherwise we're looking at an 'inside' motion.  Unfortunately these
        " get tricky when you're dealing with an empty set of delimiters because
        " Vim does the wrong thing when you say vi(.

        let open = ''
        let close = ''

        if c ==# "("
            let open = "("
            let close = ")"
        elseif c ==# "{"
            let open = "{"
            let close = "}"
        elseif c ==# "["
            let open = "\\["
            let close = "\\]"
        elseif c ==# "'"
            let open = "'"
            let close = "'"
        elseif c ==# '"'
            let open = '"'
            let close = '"'
        endif

        " We'll start at the current delimiter.
        let start_pos = getpos('.')
        let start_l = start_pos[1]
        let start_c = start_pos[2]

        " Then we'll find it's matching end delimiter.
        if c ==# "'" || c ==# '"'
            " searchpairpos() doesn't work for quotes, because fuck me.
            let end_pos = searchpos(open)
        else
            let end_pos = searchpairpos(open, '', close)
        endif

        let end_l = end_pos[0]
        let end_c = end_pos[1]

        call setpos('.', start_pos)

        if start_l == end_l && start_c == (end_c - 1)
            " We're in an empty set of delimiters.  We'll append an "x"
            " character and select that so most Vim commands will do something
            " sane.  v is gonna be weird, and so is y.  Oh well.
            execute "normal! ax\<esc>\<left>"
            execute "normal! vi" . c
        elseif start_l == end_l && start_c == (end_c - 2)
            " We're on a set of delimiters that contain a single, non-newline
            " character.  We can just select that and we're done.
            execute "normal! vi" . c
        else
            " Otherwise these delimiters contain something.  But we're still not
            " sure Vim's gonna work, because if they contain nothing but
            " newlines Vim still does the wrong thing.  So we'll manually select
            " the guts ourselves.
            let whichwrap = &whichwrap
            set whichwrap+=h,l

            execute "normal! va" . c . "hol"

            let &whichwrap = whichwrap
        endif
    endif
endfunction

" }}}
